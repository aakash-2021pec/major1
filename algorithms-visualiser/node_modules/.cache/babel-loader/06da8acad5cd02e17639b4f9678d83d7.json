{"ast":null,"code":"module.exports = function generate(options) {\n  const {\n    width,\n    height,\n    empty: EMPTY = 0,\n    wall: WALL = 1\n  } = options;\n  const OOB = {};\n\n  if (!width || !height) {\n    throw new Error('Missing required `width` & `height` options!');\n  }\n\n  const out = new Array(height);\n\n  for (let y = 0; y < out.length; y++) {\n    out[y] = new Array(width).fill(WALL);\n  }\n\n  function lookup(field, x, y, defaultValue = EMPTY) {\n    if (x < 0 || y < 0 || x >= width || y >= height) {\n      return defaultValue;\n    }\n\n    return field[y][x];\n  }\n\n  const walls = [];\n\n  function makePassage(x, y) {\n    out[y][x] = EMPTY;\n    const candidates = [{\n      x: x - 1,\n      y\n    }, {\n      x: x + 1,\n      y\n    }, {\n      x,\n      y: y - 1\n    }, {\n      x,\n      y: y + 1\n    }];\n\n    for (const wall of candidates) {\n      if (lookup(out, wall.x, wall.y) === WALL) {\n        walls.push(wall);\n      }\n    }\n  } // Pick random point and make it a passage\n\n\n  makePassage(Math.random() * width | 0, Math.random() * height | 0);\n\n  while (walls.length !== 0) {\n    const {\n      x,\n      y\n    } = walls.splice(Math.random() * walls.length | 0, 1)[0];\n    const left = lookup(out, x - 1, y, OOB);\n    const right = lookup(out, x + 1, y, OOB);\n    const top = lookup(out, x, y - 1, OOB);\n    const bottom = lookup(out, x, y + 1, OOB);\n\n    if (left === EMPTY && right === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x + 1, y);\n    } else if (right === EMPTY && left === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x - 1, y);\n    } else if (top === EMPTY && bottom === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x, y + 1);\n    } else if (bottom === EMPTY && top === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x, y - 1);\n    }\n  }\n\n  return out;\n};","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/node_modules/@indutny/maze/lib/maze.js"],"names":["module","exports","generate","options","width","height","empty","EMPTY","wall","WALL","OOB","Error","out","Array","y","length","fill","lookup","field","x","defaultValue","walls","makePassage","candidates","push","Math","random","splice","left","right","top","bottom"],"mappings":"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","sourcesContent":["module.exports = function generate(options) {\n  const {\n    width,\n    height,\n\n    empty: EMPTY = 0,\n    wall: WALL = 1,\n  } = options;\n\n  const OOB = {};\n\n  if (!width || !height) {\n    throw new Error('Missing required `width` & `height` options!');\n  }\n\n  const out = new Array(height);\n  for (let y = 0; y < out.length; y++) {\n    out[y] = new Array(width).fill(WALL);\n  }\n\n  function lookup(field, x, y, defaultValue = EMPTY) {\n    if (x < 0 || y < 0 || x >= width || y >= height) {\n      return defaultValue;\n    }\n    return field[y][x];\n  }\n\n  const walls = [];\n  function makePassage(x, y) {\n    out[y][x] = EMPTY;\n\n    const candidates = [\n      { x: x - 1, y },\n      { x: x + 1, y },\n      { x, y: y - 1 },\n      { x, y: y + 1 },\n    ];\n    for (const wall of candidates) {\n      if (lookup(out, wall.x, wall.y) === WALL) {\n        walls.push(wall);\n      }\n    }\n  }\n\n  // Pick random point and make it a passage\n  makePassage(Math.random() * width | 0, Math.random() * height | 0);\n\n  while (walls.length !== 0) {\n    const { x, y } = walls.splice((Math.random() * walls.length) | 0, 1)[0];\n\n    const left = lookup(out, x - 1, y, OOB);\n    const right = lookup(out, x + 1, y, OOB);\n    const top = lookup(out, x, y - 1, OOB);\n    const bottom = lookup(out, x, y + 1, OOB);\n\n    if (left === EMPTY && right === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x + 1, y);\n    } else if (right === EMPTY && left === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x - 1, y);\n    } else if (top === EMPTY && bottom === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x, y + 1);\n    } else if (bottom === EMPTY && top === WALL) {\n      out[y][x] = EMPTY;\n      makePassage(x, y - 1);\n    }\n  }\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"script"}