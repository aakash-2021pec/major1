{"ast":null,"code":"import generate from \"@indutny/maze\";\nexport function generateMaze(grid, ROW, COL) {\n  const maze = generate({\n    width: COL,\n    height: ROW\n  });\n\n  for (let i = 0; i < ROW; i++) {\n    for (let j = 0; j < COL; j++) {\n      const {\n        row,\n        col\n      } = grid[i][j];\n\n      if (grid[i][j].isStart || grid[i][j].isFinish) {\n        if (row > 0) maze[row - 1][col] = 0;\n        if (row < ROW - 1) maze[row + 1][col] = 0;\n        if (col > 0) maze[row][col - 1] = 0;\n        if (col < COL - 1) maze[row][col + 1] = 0;\n      }\n    }\n  }\n\n  for (let i = 0; i < ROW; i++) {\n    for (let j = 0; j < COL; j++) {\n      if (!grid[i][j].isStart && !grid[i][j].isFinish && maze[i][j] === 1) {\n        grid[i][j].isWall = true;\n      }\n    }\n  }\n\n  return grid;\n}","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/src/pathFinderVisualiser/generateMaze.js"],"names":["generate","generateMaze","grid","ROW","COL","maze","width","height","i","j","row","col","isStart","isFinish","isWall"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,eAArB;AAEA,OAAO,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,GAA5B,EAAiCC,GAAjC,EAAsC;AACzC,QAAMC,IAAI,GAAGL,QAAQ,CAAC;AAAEM,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,MAAM,EAAEJ;AAAtB,GAAD,CAArB;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC1B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC1B,YAAM;AAAEC,QAAAA,GAAF;AAAOC,QAAAA;AAAP,UAAeT,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAArB;;AACA,UAAIP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,EAAWG,OAAX,IAAsBV,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,EAAWI,QAArC,EAA+C;AAC3C,YAAIH,GAAG,GAAG,CAAV,EAAaL,IAAI,CAACK,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,IAAqB,CAArB;AACb,YAAID,GAAG,GAAGP,GAAG,GAAG,CAAhB,EAAmBE,IAAI,CAACK,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,IAAqB,CAArB;AACnB,YAAIA,GAAG,GAAG,CAAV,EAAaN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,IAAqB,CAArB;AACb,YAAIA,GAAG,GAAGP,GAAG,GAAG,CAAhB,EAAmBC,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,IAAqB,CAArB;AACtB;AACJ;AACJ;;AAED,OAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC1B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC1B,UACI,CAACP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,EAAWG,OAAZ,IACA,CAACV,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,EAAWI,QADZ,IAEAR,IAAI,CAACG,CAAD,CAAJ,CAAQC,CAAR,MAAe,CAHnB,EAIE;AACEP,QAAAA,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,EAAWK,MAAX,GAAoB,IAApB;AACH;AACJ;AACJ;;AAED,SAAOZ,IAAP;AACH","sourcesContent":["import generate from \"@indutny/maze\";\r\n\r\nexport function generateMaze(grid, ROW, COL) {\r\n    const maze = generate({ width: COL, height: ROW });\r\n    for (let i = 0; i < ROW; i++) {\r\n        for (let j = 0; j < COL; j++) {\r\n            const { row, col } = grid[i][j];\r\n            if (grid[i][j].isStart || grid[i][j].isFinish) {\r\n                if (row > 0) maze[row - 1][col] = 0;\r\n                if (row < ROW - 1) maze[row + 1][col] = 0;\r\n                if (col > 0) maze[row][col - 1] = 0;\r\n                if (col < COL - 1) maze[row][col + 1] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < ROW; i++) {\r\n        for (let j = 0; j < COL; j++) {\r\n            if (\r\n                !grid[i][j].isStart &&\r\n                !grid[i][j].isFinish &&\r\n                maze[i][j] === 1\r\n            ) {\r\n                grid[i][j].isWall = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return grid;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}