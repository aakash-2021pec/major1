{"ast":null,"code":"export function bidirectionalSearch(grid = [], startNode, finishNode) {\n  const squeue = [];\n  const dqueue = [];\n  const svisited = [],\n        dvisited = [];\n  startNode.isVisited = true;\n  startNode.previousNode = null;\n  squeue.push(startNode);\n  finishNode.isVisited = true;\n  finishNode.previousNode = null;\n  dqueue.push(finishNode);\n\n  while (squeue.length && dqueue.length) {\n    const currsn = squeue.shift();\n    const currdn = dqueue.shift();\n    const sneighbors = getAllNeighbors(grid, currsn);\n    const dneighbors = getAllNeighbors(grid, currdn);\n    if (currdn === currsn) break;\n\n    for (const sneighbor of sneighbors) {\n      if (!sneighbor.isVisited) {\n        sneighbor.isVisited = true;\n        sneighbor.previousNode = currsn;\n        squeue.push(sneighbor);\n        svisited.push(sneighbor);\n      } else {\n        break;\n      }\n    }\n\n    for (const dneighbor of dneighbors) {\n      if (!dneighbor.isVisited) {\n        dneighbor.isVisited = true;\n        dneighbor.previousNode = currdn;\n        dqueue.push(dneighbor);\n        dvisited.push(dneighbor);\n      } else {\n        break;\n      }\n    }\n  }\n\n  const sourcePaths = [],\n        destPaths = [];\n\n  for (let i = 0; i < svisited.length; i++) sourcePaths.push(calculatePath(svisited[i]));\n\n  for (let i = 0; i < dvisited.length; i++) destPaths.push(calculatePath(dvisited[i]));\n\n  for (let i = sourcePaths.length - 1; i >= 0; i--) {\n    const sPathRow = sourcePaths[i];\n    const splast = sPathRow[sPathRow.length - 1];\n    const neighbors = getAdjacents(grid, splast);\n\n    for (const neighbor of neighbors) {\n      for (let j = 0; j < destPaths.length; j++) {\n        const destPathRow = destPaths[j];\n\n        if (destPathRow.includes(neighbor)) {\n          return [svisited, dvisited, sPathRow, destPathRow];\n        }\n      }\n    }\n  }\n}\n\nfunction getAdjacents(grid = [], node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall) {\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n}\n\nfunction getAllNeighbors(grid = [], node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall && !grid[row][col + 1].isVisited) {\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n}\n\nexport function calculatePath(finishNode) {\n  const shortestPathNodes = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return shortestPathNodes;\n}","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/src/pathFinderVisualiser/pathFindingAlgorithms/bidirectionalSearch.js"],"names":["bidirectionalSearch","grid","startNode","finishNode","squeue","dqueue","svisited","dvisited","isVisited","previousNode","push","length","currsn","shift","currdn","sneighbors","getAllNeighbors","dneighbors","sneighbor","dneighbor","sourcePaths","destPaths","i","calculatePath","sPathRow","splast","neighbors","getAdjacents","neighbor","j","destPathRow","includes","node","ROWS","COLS","row","col","isWall","shortestPathNodes","currentNode","unshift"],"mappings":"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","sourcesContent":["export function bidirectionalSearch(grid = [], startNode, finishNode) {\r\n    const squeue = [];\r\n    const dqueue = [];\r\n\r\n    const svisited = [],\r\n        dvisited = [];\r\n\r\n    startNode.isVisited = true;\r\n    startNode.previousNode = null;\r\n    squeue.push(startNode);\r\n\r\n    finishNode.isVisited = true;\r\n    finishNode.previousNode = null;\r\n    dqueue.push(finishNode);\r\n\r\n    while (squeue.length && dqueue.length) {\r\n        const currsn = squeue.shift();\r\n        const currdn = dqueue.shift();\r\n\r\n        const sneighbors = getAllNeighbors(grid, currsn);\r\n        const dneighbors = getAllNeighbors(grid, currdn);\r\n\r\n        if (currdn === currsn) break;\r\n\r\n        for (const sneighbor of sneighbors) {\r\n            if (!sneighbor.isVisited) {\r\n                sneighbor.isVisited = true;\r\n                sneighbor.previousNode = currsn;\r\n                squeue.push(sneighbor);\r\n                svisited.push(sneighbor);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (const dneighbor of dneighbors) {\r\n            if (!dneighbor.isVisited) {\r\n                dneighbor.isVisited = true;\r\n                dneighbor.previousNode = currdn;\r\n                dqueue.push(dneighbor);\r\n                dvisited.push(dneighbor);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    const sourcePaths = [],\r\n        destPaths = [];\r\n\r\n    for (let i = 0; i < svisited.length; i++)\r\n        sourcePaths.push(calculatePath(svisited[i]));\r\n\r\n    for (let i = 0; i < dvisited.length; i++)\r\n        destPaths.push(calculatePath(dvisited[i]));\r\n\r\n    for (let i = sourcePaths.length - 1; i >= 0; i--) {\r\n        const sPathRow = sourcePaths[i];\r\n        const splast = sPathRow[sPathRow.length - 1];\r\n        const neighbors = getAdjacents(grid, splast);\r\n        for (const neighbor of neighbors) {\r\n            for (let j = 0; j < destPaths.length; j++) {\r\n                const destPathRow = destPaths[j];\r\n                if (destPathRow.includes(neighbor)) {\r\n                    return [svisited, dvisited, sPathRow, destPathRow];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getAdjacents(grid = [], node) {\r\n    const ROWS = grid.length;\r\n    const COLS = grid[0].length;\r\n\r\n    const { row, col } = node;\r\n    const neighbors = [];\r\n\r\n    if (\r\n        row + 1 >= 0 &&\r\n        row + 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row + 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row + 1][col]);\r\n    }\r\n    if (\r\n        row - 1 >= 0 &&\r\n        row - 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row - 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row - 1][col]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col - 1 >= 0 &&\r\n        col - 1 < COLS &&\r\n        !grid[row][col - 1].isWall\r\n    ) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col + 1 >= 0 &&\r\n        col + 1 < COLS &&\r\n        !grid[row][col + 1].isWall\r\n    ) {\r\n        neighbors.push(grid[row][col + 1]);\r\n    }\r\n\r\n    return neighbors;\r\n}\r\n\r\nfunction getAllNeighbors(grid = [], node) {\r\n    const ROWS = grid.length;\r\n    const COLS = grid[0].length;\r\n\r\n    const { row, col } = node;\r\n    const neighbors = [];\r\n\r\n    if (\r\n        row + 1 >= 0 &&\r\n        row + 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row + 1][col].isVisited &&\r\n        !grid[row + 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row + 1][col]);\r\n    }\r\n    if (\r\n        row - 1 >= 0 &&\r\n        row - 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row - 1][col].isWall &&\r\n        !grid[row - 1][col].isVisited\r\n    ) {\r\n        neighbors.push(grid[row - 1][col]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col - 1 >= 0 &&\r\n        col - 1 < COLS &&\r\n        !grid[row][col - 1].isWall &&\r\n        !grid[row][col - 1].isVisited\r\n    ) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col + 1 >= 0 &&\r\n        col + 1 < COLS &&\r\n        !grid[row][col + 1].isWall &&\r\n        !grid[row][col + 1].isVisited\r\n    ) {\r\n        neighbors.push(grid[row][col + 1]);\r\n    }\r\n\r\n    return neighbors;\r\n}\r\n\r\nexport function calculatePath(finishNode) {\r\n    const shortestPathNodes = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        shortestPathNodes.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return shortestPathNodes;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}