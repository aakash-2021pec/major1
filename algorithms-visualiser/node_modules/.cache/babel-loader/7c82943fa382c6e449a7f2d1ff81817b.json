{"ast":null,"code":"export function dfs(grid = [], startNode, finishNode) {\n  const stack = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  stack.push(startNode);\n\n  while (!!stack.length) {\n    let node = stack.pop();\n    if (finishNode === node) return [visitedNodesInOrder, calculatePath(finishNode)];\n    if (node.isWall) continue;\n    const neighbors = getAllNeighbors(grid, node);\n\n    for (const neighbor of neighbors) {\n      neighbor.isVisited = true;\n      neighbor.previousNode = node;\n      visitedNodesInOrder.push(neighbor);\n      stack.push(neighbor);\n    }\n  }\n\n  return [visitedNodesInOrder, calculatePath(finishNode)];\n}\n\nfunction calculatePath(finishNode) {\n  const shortestPathNodes = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return shortestPathNodes;\n}\n\nfunction getAllNeighbors(grid = [], node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall && !grid[row][col + 1].isVisited) {\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n}","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/src/pathFinderVisualiser/pathFindingAlgorithms/depthFirstSearch.js"],"names":["dfs","grid","startNode","finishNode","stack","visitedNodesInOrder","isVisited","push","length","node","pop","calculatePath","isWall","neighbors","getAllNeighbors","neighbor","previousNode","shortestPathNodes","currentNode","unshift","ROWS","COLS","row","col"],"mappings":"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","sourcesContent":["export function dfs(grid = [], startNode, finishNode) {\r\n    const stack = [];\r\n    const visitedNodesInOrder = [];\r\n\r\n    startNode.isVisited = true;\r\n    stack.push(startNode);\r\n\r\n    while (!!stack.length) {\r\n        let node = stack.pop();\r\n\r\n        if (finishNode === node)\r\n            return [visitedNodesInOrder, calculatePath(finishNode)];\r\n\r\n        if (node.isWall) continue;\r\n\r\n        const neighbors = getAllNeighbors(grid, node);\r\n\r\n        for (const neighbor of neighbors) {\r\n            neighbor.isVisited = true;\r\n            neighbor.previousNode = node;\r\n            visitedNodesInOrder.push(neighbor);\r\n            stack.push(neighbor);\r\n        }\r\n    }\r\n\r\n    return [visitedNodesInOrder, calculatePath(finishNode)];\r\n}\r\n\r\nfunction calculatePath(finishNode) {\r\n    const shortestPathNodes = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        shortestPathNodes.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return shortestPathNodes;\r\n}\r\n\r\nfunction getAllNeighbors(grid = [], node) {\r\n    const ROWS = grid.length;\r\n    const COLS = grid[0].length;\r\n\r\n    const { row, col } = node;\r\n    const neighbors = [];\r\n\r\n    if (\r\n        row + 1 >= 0 &&\r\n        row + 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row + 1][col].isVisited &&\r\n        !grid[row + 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row + 1][col]);\r\n    }\r\n    if (\r\n        row - 1 >= 0 &&\r\n        row - 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row - 1][col].isWall &&\r\n        !grid[row - 1][col].isVisited\r\n    ) {\r\n        neighbors.push(grid[row - 1][col]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col - 1 >= 0 &&\r\n        col - 1 < COLS &&\r\n        !grid[row][col - 1].isWall &&\r\n        !grid[row][col - 1].isVisited\r\n    ) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col + 1 >= 0 &&\r\n        col + 1 < COLS &&\r\n        !grid[row][col + 1].isWall &&\r\n        !grid[row][col + 1].isVisited\r\n    ) {\r\n        neighbors.push(grid[row][col + 1]);\r\n    }\r\n\r\n    return neighbors;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}