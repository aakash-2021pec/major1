{"ast":null,"code":"export function astar(grid = [], startNode, finishNode) {\n  const closedlist = [];\n  const openlist = [];\n  startNode.cost = {\n    F: 0,\n    G: 0,\n    H: 0\n  };\n  openlist.push(startNode);\n\n  while (!!openlist.length) {\n    openlist.sort((a, b) => a.cost.F - b.cost.F);\n    const current = openlist.shift();\n    closedlist.push(current);\n    if (current.isWall) continue;\n    if (current === finishNode) return [closedlist, calculatePath(finishNode)];\n    const neighbors = getNeighbors(grid, current);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      const nNode = neighbors[i];\n      if (closedlist.includes(nNode)) continue;\n      nNode.cost.G = calculateCost(nNode, startNode, \"E\");\n      nNode.cost.H = calculateCost(nNode, finishNode, \"E\");\n      nNode.cost.F = nNode.cost.G + nNode.cost.H;\n\n      if (!openlist.includes(nNode)) {\n        nNode.previousNode = current;\n        openlist.push(nNode);\n      }\n    }\n  }\n\n  return [closedlist, calculatePath(finishNode)];\n}\n\nfunction calculateCost(currentNode, node, distanceType) {\n  switch (distanceType) {\n    // Euclidean Distance\n    case \"E\":\n      return Math.floor(Math.sqrt(Math.pow(currentNode.row - node.row, 2) + Math.pow(currentNode.col - node.col, 2)) * 10);\n    // Manhattan Distance\n\n    case \"M\":\n      return Math.abs(currentNode.row - node.row) + Math.abs(currentNode.col - node.col);\n    // Diagonal Distance\n\n    case \"D\":\n      return Math.max(Math.abs(currentNode.row - node.row), Math.abs(currentNode.col - node.col));\n\n    default:\n      return 0;\n  }\n}\n\nfunction getNeighbors(grid = [], currentNode) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = currentNode;\n  const neighbors = []; // Top, Left, Right, Bottom Nodes\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall) {\n    neighbors.push(grid[row][col + 1]);\n  } // Diagonal Nodes\n  // if (\n  //     row - 1 >= 0 &&\n  //     row - 1 < ROWS &&\n  //     col - 1 >= 0 &&\n  //     col - 1 < COLS &&\n  //     !grid[row - 1][col - 1].isWall\n  // ) {\n  //     neighbors.push(grid[row - 1][col - 1]);\n  // }\n  // if (\n  //     row - 1 >= 0 &&\n  //     row - 1 < ROWS &&\n  //     col + 1 >= 0 &&\n  //     col + 1 < COLS &&\n  //     !grid[row - 1][col + 1].isWall\n  // ) {\n  //     neighbors.push(grid[row - 1][col + 1]);\n  // }\n  // if (\n  //     row + 1 >= 0 &&\n  //     row + 1 < ROWS &&\n  //     col - 1 >= 0 &&\n  //     col - 1 < COLS &&\n  //     !grid[row + 1][col - 1].isWall\n  // ) {\n  //     neighbors.push(grid[row + 1][col - 1]);\n  // }\n  // if (\n  //     row + 1 >= 0 &&\n  //     row + 1 < ROWS &&\n  //     col + 1 >= 0 &&\n  //     col + 1 < COLS &&\n  //     !grid[row + 1][col + 1].isWall\n  // ) {\n  //     neighbors.push(grid[row + 1][col + 1]);\n  // }\n\n\n  return neighbors;\n}\n\nfunction calculatePath(finishNode) {\n  const shortestPathNodes = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return shortestPathNodes;\n}","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/src/pathFinderVisualiser/pathFindingAlgorithms/astar.js"],"names":["astar","grid","startNode","finishNode","closedlist","openlist","cost","F","G","H","push","length","sort","a","b","current","shift","isWall","calculatePath","neighbors","getNeighbors","i","nNode","includes","calculateCost","previousNode","currentNode","node","distanceType","Math","floor","sqrt","pow","row","col","abs","max","ROWS","COLS","shortestPathNodes","unshift"],"mappings":"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","sourcesContent":["export function astar(grid = [], startNode, finishNode) {\r\n    const closedlist = [];\r\n    const openlist = [];\r\n\r\n    startNode.cost = {\r\n        F: 0,\r\n        G: 0,\r\n        H: 0,\r\n    };\r\n\r\n    openlist.push(startNode);\r\n\r\n    while (!!openlist.length) {\r\n        openlist.sort((a, b) => a.cost.F - b.cost.F);\r\n        const current = openlist.shift();\r\n\r\n        closedlist.push(current);\r\n\r\n        if (current.isWall) continue;\r\n\r\n        if (current === finishNode)\r\n            return [closedlist, calculatePath(finishNode)];\r\n\r\n        const neighbors = getNeighbors(grid, current);\r\n\r\n        for (let i = 0; i < neighbors.length; i++) {\r\n            const nNode = neighbors[i];\r\n            if (closedlist.includes(nNode)) continue;\r\n\r\n            nNode.cost.G = calculateCost(nNode, startNode, \"E\");\r\n            nNode.cost.H = calculateCost(nNode, finishNode, \"E\");\r\n            nNode.cost.F = nNode.cost.G + nNode.cost.H;\r\n\r\n            if (!openlist.includes(nNode)) {\r\n                nNode.previousNode = current;\r\n                openlist.push(nNode);\r\n            }\r\n        }\r\n    }\r\n    return [closedlist, calculatePath(finishNode)];\r\n}\r\n\r\nfunction calculateCost(currentNode, node, distanceType) {\r\n    switch (distanceType) {\r\n        // Euclidean Distance\r\n        case \"E\":\r\n            return Math.floor(\r\n                Math.sqrt(\r\n                    Math.pow(currentNode.row - node.row, 2) +\r\n                        Math.pow(currentNode.col - node.col, 2)\r\n                ) * 10\r\n            );\r\n\r\n        // Manhattan Distance\r\n        case \"M\":\r\n            return (\r\n                Math.abs(currentNode.row - node.row) +\r\n                Math.abs(currentNode.col - node.col)\r\n            );\r\n\r\n        // Diagonal Distance\r\n        case \"D\":\r\n            return Math.max(\r\n                Math.abs(currentNode.row - node.row),\r\n                Math.abs(currentNode.col - node.col)\r\n            );\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\nfunction getNeighbors(grid = [], currentNode) {\r\n    const ROWS = grid.length;\r\n    const COLS = grid[0].length;\r\n    const { row, col } = currentNode;\r\n    const neighbors = [];\r\n\r\n    // Top, Left, Right, Bottom Nodes\r\n    if (\r\n        row + 1 >= 0 &&\r\n        row + 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row + 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row + 1][col]);\r\n    }\r\n    if (\r\n        row - 1 >= 0 &&\r\n        row - 1 < ROWS &&\r\n        col >= 0 &&\r\n        col < COLS &&\r\n        !grid[row - 1][col].isWall\r\n    ) {\r\n        neighbors.push(grid[row - 1][col]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col - 1 >= 0 &&\r\n        col - 1 < COLS &&\r\n        !grid[row][col - 1].isWall\r\n    ) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if (\r\n        row >= 0 &&\r\n        row < ROWS &&\r\n        col + 1 >= 0 &&\r\n        col + 1 < COLS &&\r\n        !grid[row][col + 1].isWall\r\n    ) {\r\n        neighbors.push(grid[row][col + 1]);\r\n    }\r\n\r\n    // Diagonal Nodes\r\n    // if (\r\n    //     row - 1 >= 0 &&\r\n    //     row - 1 < ROWS &&\r\n    //     col - 1 >= 0 &&\r\n    //     col - 1 < COLS &&\r\n    //     !grid[row - 1][col - 1].isWall\r\n    // ) {\r\n    //     neighbors.push(grid[row - 1][col - 1]);\r\n    // }\r\n    // if (\r\n    //     row - 1 >= 0 &&\r\n    //     row - 1 < ROWS &&\r\n    //     col + 1 >= 0 &&\r\n    //     col + 1 < COLS &&\r\n    //     !grid[row - 1][col + 1].isWall\r\n    // ) {\r\n    //     neighbors.push(grid[row - 1][col + 1]);\r\n    // }\r\n    // if (\r\n    //     row + 1 >= 0 &&\r\n    //     row + 1 < ROWS &&\r\n    //     col - 1 >= 0 &&\r\n    //     col - 1 < COLS &&\r\n    //     !grid[row + 1][col - 1].isWall\r\n    // ) {\r\n    //     neighbors.push(grid[row + 1][col - 1]);\r\n    // }\r\n    // if (\r\n    //     row + 1 >= 0 &&\r\n    //     row + 1 < ROWS &&\r\n    //     col + 1 >= 0 &&\r\n    //     col + 1 < COLS &&\r\n    //     !grid[row + 1][col + 1].isWall\r\n    // ) {\r\n    //     neighbors.push(grid[row + 1][col + 1]);\r\n    // }\r\n\r\n    return neighbors;\r\n}\r\n\r\nfunction calculatePath(finishNode) {\r\n    const shortestPathNodes = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        shortestPathNodes.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return shortestPathNodes;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}