{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return [visitedNodesInOrder, calculatePath(finishNode)];\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return [visitedNodesInOrder, calculatePath(finishNode)];\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function getAllNodes(grid = []) {\n  const nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      nodes.push(grid[i][j]);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction calculatePath(finishNode) {\n  const shortestPathNodes = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return shortestPathNodes;\n}","map":{"version":3,"sources":["C:/Users/sharm/OneDrive/Documents/GitHub/major1/algorithms-visualiser/src/pathFinderVisualiser/pathFindingAlgorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","calculatePath","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","nodes","i","j","getUnvisitedNeighbors","node","neighbors","col","row","filter","neighbor","unvisitedNeighbors","previousNode","shortestPathNodes","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n\r\n        if (closestNode.isWall) continue;\r\n\r\n        if (closestNode.distance === Infinity)\r\n            return [visitedNodesInOrder, calculatePath(finishNode)];\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if (closestNode === finishNode)\r\n        return [visitedNodesInOrder, calculatePath(finishNode)];\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function getAllNodes(grid = []) {\r\n    const nodes = [];\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            nodes.push(grid[i][j]);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction calculatePath(finishNode) {\r\n    const shortestPathNodes = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        shortestPathNodes.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return shortestPathNodes;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}